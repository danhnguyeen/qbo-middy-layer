"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(module, "exports", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _util = require("@middy/util");
const httpRouteHandler = (routes)=>{
    const routesStatic = {};
    const routesDynamic = {};
    const enumMethods = methods.concat('ANY');
    for (const route of routes){
        let { method, path, handler } = route;
        if (!enumMethods.includes(method)) {
            throw new Error('[http-router] Method not allowed');
        }
        if (path.endsWith('/') && path !== '/') {
            path = path.substr(0, path.length - 1);
        }
        if (path.indexOf('{') < 0) {
            attachStaticRoute(method, path, handler, routesStatic);
            continue;
        }
        attachDynamicRoute(method, path, handler, routesDynamic);
    }
    return (event, context, abort)=>{
        const { method, path } = getVersionRoute[pickVersion(event)]?.(event);
        if (!method) {
            throw new Error('[http-router] Unknown http event format');
        }
        const handler = routesStatic[method]?.[path];
        if (typeof handler !== 'undefined') {
            return handler(event, context, abort);
        }
        for (const route of routesDynamic[method] ?? []){
            const match = path.match(route.path);
            if (match) {
                event.pathParameters = {
                    ...match.groups,
                    ...event.pathParameters
                };
                return route.handler(event, context, abort);
            }
        }
        throw (0, _util.createError)(404, 'Route does not exist');
    };
};
const regexpDynamicWildcards = /\/\{(proxy)\+\}$/;
const regexpDynamicParameters = /\/\{([^/]+)\}/g;
const methods = [
    'GET',
    'POST',
    'PUT',
    'PATCH',
    'DELETE',
    'OPTIONS',
    'HEAD'
];
const attachStaticRoute = (method, path, handler, routesType)=>{
    if (method === 'ANY') {
        for (const method of methods){
            attachStaticRoute(method, path, handler, routesType);
        }
        return;
    }
    if (!routesType[method]) {
        routesType[method] = {};
    }
    routesType[method][path] = handler;
    routesType[method][path + '/'] = handler;
};
const attachDynamicRoute = (method, path, handler, routesType)=>{
    if (method === 'ANY') {
        for (const method of methods){
            attachDynamicRoute(method, path, handler, routesType);
        }
        return;
    }
    if (!routesType[method]) {
        routesType[method] = [];
    }
    path = path.replace(regexpDynamicWildcards, '/?(?<$1>.*)').replace(regexpDynamicParameters, '/(?<$1>[^/]+)');
    path = new RegExp(`^${path}/?$`);
    routesType[method].push({
        path,
        handler
    });
};
const pickVersion = (event)=>{
    return event.version ?? (event.method ? 'vpc' : '1.0');
};
const getVersionRoute = {
    '1.0': (event)=>({
            method: event.httpMethod,
            path: event.path
        }),
    '2.0': (event)=>({
            method: event.requestContext.http.method,
            path: event.requestContext.http.path
        }),
    vpc: (event)=>({
            method: event.method,
            path: event.raw_path.split('?')[0]
        })
};
const _default = httpRouteHandler;

