var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@fluent/syntax/index.js
var require_syntax = __commonJS({
  "node_modules/@fluent/syntax/index.js"(exports, module2) {
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define("@fluent/syntax", ["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.FluentSyntax = {}));
    })(exports, function(exports2) {
      "use strict";
      class BaseNode {
        equals(other, ignoredFields = ["span"]) {
          const thisKeys = new Set(Object.keys(this));
          const otherKeys = new Set(Object.keys(other));
          if (ignoredFields) {
            for (const fieldName of ignoredFields) {
              thisKeys.delete(fieldName);
              otherKeys.delete(fieldName);
            }
          }
          if (thisKeys.size !== otherKeys.size) {
            return false;
          }
          for (const fieldName of thisKeys) {
            if (!otherKeys.has(fieldName)) {
              return false;
            }
            const thisVal = this[fieldName];
            const otherVal = other[fieldName];
            if (typeof thisVal !== typeof otherVal) {
              return false;
            }
            if (thisVal instanceof Array && otherVal instanceof Array) {
              if (thisVal.length !== otherVal.length) {
                return false;
              }
              for (let i = 0; i < thisVal.length; ++i) {
                if (!scalarsEqual(thisVal[i], otherVal[i], ignoredFields)) {
                  return false;
                }
              }
            } else if (!scalarsEqual(thisVal, otherVal, ignoredFields)) {
              return false;
            }
          }
          return true;
        }
        clone() {
          function visit(value) {
            if (value instanceof BaseNode) {
              return value.clone();
            }
            if (Array.isArray(value)) {
              return value.map(visit);
            }
            return value;
          }
          const clone = Object.create(this.constructor.prototype);
          for (const prop of Object.keys(this)) {
            clone[prop] = visit(this[prop]);
          }
          return clone;
        }
      }
      function scalarsEqual(thisVal, otherVal, ignoredFields) {
        if (thisVal instanceof BaseNode && otherVal instanceof BaseNode) {
          return thisVal.equals(otherVal, ignoredFields);
        }
        return thisVal === otherVal;
      }
      class SyntaxNode extends BaseNode {
        addSpan(start, end) {
          this.span = new Span(start, end);
        }
      }
      class Resource extends SyntaxNode {
        constructor(body = []) {
          super();
          this.type = "Resource";
          this.body = body;
        }
      }
      class Message extends SyntaxNode {
        constructor(id, value = null, attributes = [], comment = null) {
          super();
          this.type = "Message";
          this.id = id;
          this.value = value;
          this.attributes = attributes;
          this.comment = comment;
        }
      }
      class Term extends SyntaxNode {
        constructor(id, value, attributes = [], comment = null) {
          super();
          this.type = "Term";
          this.id = id;
          this.value = value;
          this.attributes = attributes;
          this.comment = comment;
        }
      }
      class Pattern extends SyntaxNode {
        constructor(elements2) {
          super();
          this.type = "Pattern";
          this.elements = elements2;
        }
      }
      class TextElement extends SyntaxNode {
        constructor(value) {
          super();
          this.type = "TextElement";
          this.value = value;
        }
      }
      class Placeable extends SyntaxNode {
        constructor(expression) {
          super();
          this.type = "Placeable";
          this.expression = expression;
        }
      }
      class BaseLiteral extends SyntaxNode {
        constructor(value) {
          super();
          this.value = value;
        }
      }
      class StringLiteral extends BaseLiteral {
        constructor() {
          super(...arguments);
          this.type = "StringLiteral";
        }
        parse() {
          const KNOWN_ESCAPES = /(?:\\\\|\\"|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
          function fromEscapeSequence(match, codepoint4, codepoint6) {
            switch (match) {
              case "\\\\":
                return "\\";
              case '\\"':
                return '"';
              default: {
                let codepoint = parseInt(codepoint4 || codepoint6, 16);
                if (codepoint <= 55295 || 57344 <= codepoint) {
                  return String.fromCodePoint(codepoint);
                }
                return "\uFFFD";
              }
            }
          }
          let value = this.value.replace(KNOWN_ESCAPES, fromEscapeSequence);
          return { value };
        }
      }
      class NumberLiteral extends BaseLiteral {
        constructor() {
          super(...arguments);
          this.type = "NumberLiteral";
        }
        parse() {
          let value = parseFloat(this.value);
          let decimalPos = this.value.indexOf(".");
          let precision = decimalPos > 0 ? this.value.length - decimalPos - 1 : 0;
          return { value, precision };
        }
      }
      class MessageReference extends SyntaxNode {
        constructor(id, attribute = null) {
          super();
          this.type = "MessageReference";
          this.id = id;
          this.attribute = attribute;
        }
      }
      class TermReference extends SyntaxNode {
        constructor(id, attribute = null, args = null) {
          super();
          this.type = "TermReference";
          this.id = id;
          this.attribute = attribute;
          this.arguments = args;
        }
      }
      class VariableReference extends SyntaxNode {
        constructor(id) {
          super();
          this.type = "VariableReference";
          this.id = id;
        }
      }
      class FunctionReference extends SyntaxNode {
        constructor(id, args) {
          super();
          this.type = "FunctionReference";
          this.id = id;
          this.arguments = args;
        }
      }
      class SelectExpression extends SyntaxNode {
        constructor(selector, variants) {
          super();
          this.type = "SelectExpression";
          this.selector = selector;
          this.variants = variants;
        }
      }
      class CallArguments extends SyntaxNode {
        constructor(positional = [], named = []) {
          super();
          this.type = "CallArguments";
          this.positional = positional;
          this.named = named;
        }
      }
      class Attribute extends SyntaxNode {
        constructor(id, value) {
          super();
          this.type = "Attribute";
          this.id = id;
          this.value = value;
        }
      }
      class Variant extends SyntaxNode {
        constructor(key, value, def) {
          super();
          this.type = "Variant";
          this.key = key;
          this.value = value;
          this.default = def;
        }
      }
      class NamedArgument extends SyntaxNode {
        constructor(name, value) {
          super();
          this.type = "NamedArgument";
          this.name = name;
          this.value = value;
        }
      }
      class Identifier extends SyntaxNode {
        constructor(name) {
          super();
          this.type = "Identifier";
          this.name = name;
        }
      }
      class BaseComment extends SyntaxNode {
        constructor(content) {
          super();
          this.content = content;
        }
      }
      class Comment extends BaseComment {
        constructor() {
          super(...arguments);
          this.type = "Comment";
        }
      }
      class GroupComment extends BaseComment {
        constructor() {
          super(...arguments);
          this.type = "GroupComment";
        }
      }
      class ResourceComment extends BaseComment {
        constructor() {
          super(...arguments);
          this.type = "ResourceComment";
        }
      }
      class Junk extends SyntaxNode {
        constructor(content) {
          super();
          this.type = "Junk";
          this.annotations = [];
          this.content = content;
        }
        addAnnotation(annotation) {
          this.annotations.push(annotation);
        }
      }
      class Span extends BaseNode {
        constructor(start, end) {
          super();
          this.type = "Span";
          this.start = start;
          this.end = end;
        }
      }
      class Annotation extends SyntaxNode {
        constructor(code, args = [], message) {
          super();
          this.type = "Annotation";
          this.code = code;
          this.arguments = args;
          this.message = message;
        }
      }
      class ParseError extends Error {
        constructor(code, ...args) {
          super();
          this.code = code;
          this.args = args;
          this.message = getErrorMessage(code, args);
        }
      }
      function getErrorMessage(code, args) {
        switch (code) {
          case "E0001":
            return "Generic error";
          case "E0002":
            return "Expected an entry start";
          case "E0003": {
            const [token] = args;
            return `Expected token: "${token}"`;
          }
          case "E0004": {
            const [range] = args;
            return `Expected a character from range: "${range}"`;
          }
          case "E0005": {
            const [id] = args;
            return `Expected message "${id}" to have a value or attributes`;
          }
          case "E0006": {
            const [id] = args;
            return `Expected term "-${id}" to have a value`;
          }
          case "E0007":
            return "Keyword cannot end with a whitespace";
          case "E0008":
            return "The callee has to be an upper-case identifier or a term";
          case "E0009":
            return "The argument name has to be a simple identifier";
          case "E0010":
            return "Expected one of the variants to be marked as default (*)";
          case "E0011":
            return 'Expected at least one variant after "->"';
          case "E0012":
            return "Expected value";
          case "E0013":
            return "Expected variant key";
          case "E0014":
            return "Expected literal";
          case "E0015":
            return "Only one variant can be marked as default (*)";
          case "E0016":
            return "Message references cannot be used as selectors";
          case "E0017":
            return "Terms cannot be used as selectors";
          case "E0018":
            return "Attributes of messages cannot be used as selectors";
          case "E0019":
            return "Attributes of terms cannot be used as placeables";
          case "E0020":
            return "Unterminated string expression";
          case "E0021":
            return "Positional arguments must not follow named arguments";
          case "E0022":
            return "Named arguments must be unique";
          case "E0024":
            return "Cannot access variants of a message.";
          case "E0025": {
            const [char] = args;
            return `Unknown escape sequence: \\${char}.`;
          }
          case "E0026": {
            const [sequence] = args;
            return `Invalid Unicode escape sequence: ${sequence}.`;
          }
          case "E0027":
            return "Unbalanced closing brace in TextElement.";
          case "E0028":
            return "Expected an inline expression";
          case "E0029":
            return "Expected simple expression as selector";
          default:
            return code;
        }
      }
      class ParserStream {
        constructor(string) {
          this.string = string;
          this.index = 0;
          this.peekOffset = 0;
        }
        charAt(offset) {
          if (this.string[offset] === "\r" && this.string[offset + 1] === "\n") {
            return "\n";
          }
          return this.string[offset];
        }
        currentChar() {
          return this.charAt(this.index);
        }
        currentPeek() {
          return this.charAt(this.index + this.peekOffset);
        }
        next() {
          this.peekOffset = 0;
          if (this.string[this.index] === "\r" && this.string[this.index + 1] === "\n") {
            this.index++;
          }
          this.index++;
          return this.string[this.index];
        }
        peek() {
          if (this.string[this.index + this.peekOffset] === "\r" && this.string[this.index + this.peekOffset + 1] === "\n") {
            this.peekOffset++;
          }
          this.peekOffset++;
          return this.string[this.index + this.peekOffset];
        }
        resetPeek(offset = 0) {
          this.peekOffset = offset;
        }
        skipToPeek() {
          this.index += this.peekOffset;
          this.peekOffset = 0;
        }
      }
      const EOL = "\n";
      const EOF = void 0;
      const SPECIAL_LINE_START_CHARS = ["}", ".", "[", "*"];
      class FluentParserStream extends ParserStream {
        peekBlankInline() {
          const start = this.index + this.peekOffset;
          while (this.currentPeek() === " ") {
            this.peek();
          }
          return this.string.slice(start, this.index + this.peekOffset);
        }
        skipBlankInline() {
          const blank = this.peekBlankInline();
          this.skipToPeek();
          return blank;
        }
        peekBlankBlock() {
          let blank = "";
          while (true) {
            const lineStart = this.peekOffset;
            this.peekBlankInline();
            if (this.currentPeek() === EOL) {
              blank += EOL;
              this.peek();
              continue;
            }
            if (this.currentPeek() === EOF) {
              return blank;
            }
            this.resetPeek(lineStart);
            return blank;
          }
        }
        skipBlankBlock() {
          const blank = this.peekBlankBlock();
          this.skipToPeek();
          return blank;
        }
        peekBlank() {
          while (this.currentPeek() === " " || this.currentPeek() === EOL) {
            this.peek();
          }
        }
        skipBlank() {
          this.peekBlank();
          this.skipToPeek();
        }
        expectChar(ch) {
          if (this.currentChar() === ch) {
            this.next();
            return;
          }
          throw new ParseError("E0003", ch);
        }
        expectLineEnd() {
          if (this.currentChar() === EOF) {
            return;
          }
          if (this.currentChar() === EOL) {
            this.next();
            return;
          }
          throw new ParseError("E0003", "\u2424");
        }
        takeChar(f) {
          const ch = this.currentChar();
          if (ch === EOF) {
            return EOF;
          }
          if (f(ch)) {
            this.next();
            return ch;
          }
          return null;
        }
        isCharIdStart(ch) {
          if (ch === EOF) {
            return false;
          }
          const cc = ch.charCodeAt(0);
          return cc >= 97 && cc <= 122 || // a-z
          cc >= 65 && cc <= 90;
        }
        isIdentifierStart() {
          return this.isCharIdStart(this.currentPeek());
        }
        isNumberStart() {
          const ch = this.currentChar() === "-" ? this.peek() : this.currentChar();
          if (ch === EOF) {
            this.resetPeek();
            return false;
          }
          const cc = ch.charCodeAt(0);
          const isDigit = cc >= 48 && cc <= 57;
          this.resetPeek();
          return isDigit;
        }
        isCharPatternContinuation(ch) {
          if (ch === EOF) {
            return false;
          }
          return !SPECIAL_LINE_START_CHARS.includes(ch);
        }
        isValueStart() {
          const ch = this.currentPeek();
          return ch !== EOL && ch !== EOF;
        }
        isValueContinuation() {
          const column1 = this.peekOffset;
          this.peekBlankInline();
          if (this.currentPeek() === "{") {
            this.resetPeek(column1);
            return true;
          }
          if (this.peekOffset - column1 === 0) {
            return false;
          }
          if (this.isCharPatternContinuation(this.currentPeek())) {
            this.resetPeek(column1);
            return true;
          }
          return false;
        }
        // -1 - any
        //  0 - comment
        //  1 - group comment
        //  2 - resource comment
        isNextLineComment(level = -1) {
          if (this.currentChar() !== EOL) {
            return false;
          }
          let i = 0;
          while (i <= level || level === -1 && i < 3) {
            if (this.peek() !== "#") {
              if (i <= level && level !== -1) {
                this.resetPeek();
                return false;
              }
              break;
            }
            i++;
          }
          const ch = this.peek();
          if (ch === " " || ch === EOL) {
            this.resetPeek();
            return true;
          }
          this.resetPeek();
          return false;
        }
        isVariantStart() {
          const currentPeekOffset = this.peekOffset;
          if (this.currentPeek() === "*") {
            this.peek();
          }
          if (this.currentPeek() === "[") {
            this.resetPeek(currentPeekOffset);
            return true;
          }
          this.resetPeek(currentPeekOffset);
          return false;
        }
        isAttributeStart() {
          return this.currentPeek() === ".";
        }
        skipToNextEntryStart(junkStart) {
          let lastNewline = this.string.lastIndexOf(EOL, this.index);
          if (junkStart < lastNewline) {
            this.index = lastNewline;
          }
          while (this.currentChar()) {
            if (this.currentChar() !== EOL) {
              this.next();
              continue;
            }
            const first = this.next();
            if (this.isCharIdStart(first) || first === "-" || first === "#") {
              break;
            }
          }
        }
        takeIDStart() {
          if (this.isCharIdStart(this.currentChar())) {
            const ret = this.currentChar();
            this.next();
            return ret;
          }
          throw new ParseError("E0004", "a-zA-Z");
        }
        takeIDChar() {
          const closure = (ch) => {
            const cc = ch.charCodeAt(0);
            return cc >= 97 && cc <= 122 || // a-z
            cc >= 65 && cc <= 90 || // A-Z
            cc >= 48 && cc <= 57 || // 0-9
            cc === 95 || cc === 45;
          };
          return this.takeChar(closure);
        }
        takeDigit() {
          const closure = (ch) => {
            const cc = ch.charCodeAt(0);
            return cc >= 48 && cc <= 57;
          };
          return this.takeChar(closure);
        }
        takeHexDigit() {
          const closure = (ch) => {
            const cc = ch.charCodeAt(0);
            return cc >= 48 && cc <= 57 || cc >= 65 && cc <= 70 || cc >= 97 && cc <= 102;
          };
          return this.takeChar(closure);
        }
      }
      const trailingWSRe = /[ \t\n\r]+$/;
      function withSpan(fn) {
        return function(ps, ...args) {
          if (!this.withSpans) {
            return fn.call(this, ps, ...args);
          }
          const start = ps.index;
          const node = fn.call(this, ps, ...args);
          if (node.span) {
            return node;
          }
          const end = ps.index;
          node.addSpan(start, end);
          return node;
        };
      }
      class FluentParser {
        constructor({ withSpans = true } = {}) {
          this.withSpans = withSpans;
          this.getComment = withSpan(this.getComment);
          this.getMessage = withSpan(this.getMessage);
          this.getTerm = withSpan(this.getTerm);
          this.getAttribute = withSpan(this.getAttribute);
          this.getIdentifier = withSpan(this.getIdentifier);
          this.getVariant = withSpan(this.getVariant);
          this.getNumber = withSpan(this.getNumber);
          this.getPattern = withSpan(this.getPattern);
          this.getTextElement = withSpan(this.getTextElement);
          this.getPlaceable = withSpan(this.getPlaceable);
          this.getExpression = withSpan(this.getExpression);
          this.getInlineExpression = withSpan(this.getInlineExpression);
          this.getCallArgument = withSpan(this.getCallArgument);
          this.getCallArguments = withSpan(this.getCallArguments);
          this.getString = withSpan(this.getString);
          this.getLiteral = withSpan(this.getLiteral);
          this.getComment = withSpan(this.getComment);
        }
        parse(source) {
          const ps = new FluentParserStream(source);
          ps.skipBlankBlock();
          const entries = [];
          let lastComment = null;
          while (ps.currentChar()) {
            const entry = this.getEntryOrJunk(ps);
            const blankLines = ps.skipBlankBlock();
            if (entry instanceof Comment && blankLines.length === 0 && ps.currentChar()) {
              lastComment = entry;
              continue;
            }
            if (lastComment) {
              if (entry instanceof Message || entry instanceof Term) {
                entry.comment = lastComment;
                if (this.withSpans) {
                  entry.span.start = entry.comment.span.start;
                }
              } else {
                entries.push(lastComment);
              }
              lastComment = null;
            }
            entries.push(entry);
          }
          const res = new Resource(entries);
          if (this.withSpans) {
            res.addSpan(0, ps.index);
          }
          return res;
        }
        /*
         * Parse the first Message or Term in `source`.
         *
         * Skip all encountered comments and start parsing at the first Message or
         * Term start. Return Junk if the parsing is not successful.
         *
         * Preceding comments are ignored unless they contain syntax errors
         * themselves, in which case Junk for the invalid comment is returned.
         */
        parseEntry(source) {
          const ps = new FluentParserStream(source);
          ps.skipBlankBlock();
          while (ps.currentChar() === "#") {
            const skipped = this.getEntryOrJunk(ps);
            if (skipped instanceof Junk) {
              return skipped;
            }
            ps.skipBlankBlock();
          }
          return this.getEntryOrJunk(ps);
        }
        getEntryOrJunk(ps) {
          const entryStartPos = ps.index;
          try {
            const entry = this.getEntry(ps);
            ps.expectLineEnd();
            return entry;
          } catch (err) {
            if (!(err instanceof ParseError)) {
              throw err;
            }
            let errorIndex = ps.index;
            ps.skipToNextEntryStart(entryStartPos);
            const nextEntryStart = ps.index;
            if (nextEntryStart < errorIndex) {
              errorIndex = nextEntryStart;
            }
            const slice = ps.string.substring(entryStartPos, nextEntryStart);
            const junk = new Junk(slice);
            if (this.withSpans) {
              junk.addSpan(entryStartPos, nextEntryStart);
            }
            const annot = new Annotation(err.code, err.args, err.message);
            annot.addSpan(errorIndex, errorIndex);
            junk.addAnnotation(annot);
            return junk;
          }
        }
        getEntry(ps) {
          if (ps.currentChar() === "#") {
            return this.getComment(ps);
          }
          if (ps.currentChar() === "-") {
            return this.getTerm(ps);
          }
          if (ps.isIdentifierStart()) {
            return this.getMessage(ps);
          }
          throw new ParseError("E0002");
        }
        getComment(ps) {
          let level = -1;
          let content = "";
          while (true) {
            let i = -1;
            while (ps.currentChar() === "#" && i < (level === -1 ? 2 : level)) {
              ps.next();
              i++;
            }
            if (level === -1) {
              level = i;
            }
            if (ps.currentChar() !== EOL) {
              ps.expectChar(" ");
              let ch;
              while (ch = ps.takeChar((x) => x !== EOL)) {
                content += ch;
              }
            }
            if (ps.isNextLineComment(level)) {
              content += ps.currentChar();
              ps.next();
            } else {
              break;
            }
          }
          let Comment$1;
          switch (level) {
            case 0:
              Comment$1 = Comment;
              break;
            case 1:
              Comment$1 = GroupComment;
              break;
            default:
              Comment$1 = ResourceComment;
          }
          return new Comment$1(content);
        }
        getMessage(ps) {
          const id = this.getIdentifier(ps);
          ps.skipBlankInline();
          ps.expectChar("=");
          const value = this.maybeGetPattern(ps);
          const attrs = this.getAttributes(ps);
          if (value === null && attrs.length === 0) {
            throw new ParseError("E0005", id.name);
          }
          return new Message(id, value, attrs);
        }
        getTerm(ps) {
          ps.expectChar("-");
          const id = this.getIdentifier(ps);
          ps.skipBlankInline();
          ps.expectChar("=");
          const value = this.maybeGetPattern(ps);
          if (value === null) {
            throw new ParseError("E0006", id.name);
          }
          const attrs = this.getAttributes(ps);
          return new Term(id, value, attrs);
        }
        getAttribute(ps) {
          ps.expectChar(".");
          const key = this.getIdentifier(ps);
          ps.skipBlankInline();
          ps.expectChar("=");
          const value = this.maybeGetPattern(ps);
          if (value === null) {
            throw new ParseError("E0012");
          }
          return new Attribute(key, value);
        }
        getAttributes(ps) {
          const attrs = [];
          ps.peekBlank();
          while (ps.isAttributeStart()) {
            ps.skipToPeek();
            const attr = this.getAttribute(ps);
            attrs.push(attr);
            ps.peekBlank();
          }
          return attrs;
        }
        getIdentifier(ps) {
          let name = ps.takeIDStart();
          let ch;
          while (ch = ps.takeIDChar()) {
            name += ch;
          }
          return new Identifier(name);
        }
        getVariantKey(ps) {
          const ch = ps.currentChar();
          if (ch === EOF) {
            throw new ParseError("E0013");
          }
          const cc = ch.charCodeAt(0);
          if (cc >= 48 && cc <= 57 || cc === 45) {
            return this.getNumber(ps);
          }
          return this.getIdentifier(ps);
        }
        getVariant(ps, hasDefault = false) {
          let defaultIndex = false;
          if (ps.currentChar() === "*") {
            if (hasDefault) {
              throw new ParseError("E0015");
            }
            ps.next();
            defaultIndex = true;
          }
          ps.expectChar("[");
          ps.skipBlank();
          const key = this.getVariantKey(ps);
          ps.skipBlank();
          ps.expectChar("]");
          const value = this.maybeGetPattern(ps);
          if (value === null) {
            throw new ParseError("E0012");
          }
          return new Variant(key, value, defaultIndex);
        }
        getVariants(ps) {
          const variants = [];
          let hasDefault = false;
          ps.skipBlank();
          while (ps.isVariantStart()) {
            const variant = this.getVariant(ps, hasDefault);
            if (variant.default) {
              hasDefault = true;
            }
            variants.push(variant);
            ps.expectLineEnd();
            ps.skipBlank();
          }
          if (variants.length === 0) {
            throw new ParseError("E0011");
          }
          if (!hasDefault) {
            throw new ParseError("E0010");
          }
          return variants;
        }
        getDigits(ps) {
          let num = "";
          let ch;
          while (ch = ps.takeDigit()) {
            num += ch;
          }
          if (num.length === 0) {
            throw new ParseError("E0004", "0-9");
          }
          return num;
        }
        getNumber(ps) {
          let value = "";
          if (ps.currentChar() === "-") {
            ps.next();
            value += `-${this.getDigits(ps)}`;
          } else {
            value += this.getDigits(ps);
          }
          if (ps.currentChar() === ".") {
            ps.next();
            value += `.${this.getDigits(ps)}`;
          }
          return new NumberLiteral(value);
        }
        // maybeGetPattern distinguishes between patterns which start on the same line
        // as the identifier (a.k.a. inline signleline patterns and inline multiline
        // patterns) and patterns which start on a new line (a.k.a. block multiline
        // patterns). The distinction is important for the dedentation logic: the
        // indent of the first line of a block pattern must be taken into account when
        // calculating the maximum common indent.
        maybeGetPattern(ps) {
          ps.peekBlankInline();
          if (ps.isValueStart()) {
            ps.skipToPeek();
            return this.getPattern(ps, false);
          }
          ps.peekBlankBlock();
          if (ps.isValueContinuation()) {
            ps.skipToPeek();
            return this.getPattern(ps, true);
          }
          return null;
        }
        getPattern(ps, isBlock) {
          const elements2 = [];
          let commonIndentLength;
          if (isBlock) {
            const blankStart = ps.index;
            const firstIndent = ps.skipBlankInline();
            elements2.push(this.getIndent(ps, firstIndent, blankStart));
            commonIndentLength = firstIndent.length;
          } else {
            commonIndentLength = Infinity;
          }
          let ch;
          elements:
            while (ch = ps.currentChar()) {
              switch (ch) {
                case EOL: {
                  const blankStart = ps.index;
                  const blankLines = ps.peekBlankBlock();
                  if (ps.isValueContinuation()) {
                    ps.skipToPeek();
                    const indent = ps.skipBlankInline();
                    commonIndentLength = Math.min(commonIndentLength, indent.length);
                    elements2.push(this.getIndent(ps, blankLines + indent, blankStart));
                    continue elements;
                  }
                  ps.resetPeek();
                  break elements;
                }
                case "{":
                  elements2.push(this.getPlaceable(ps));
                  continue elements;
                case "}":
                  throw new ParseError("E0027");
                default:
                  elements2.push(this.getTextElement(ps));
              }
            }
          const dedented = this.dedent(elements2, commonIndentLength);
          return new Pattern(dedented);
        }
        // Create a token representing an indent. It's not part of the AST and it will
        // be trimmed and merged into adjacent TextElements, or turned into a new
        // TextElement, if it's surrounded by two Placeables.
        getIndent(ps, value, start) {
          return new Indent(value, start, ps.index);
        }
        // Dedent a list of elements by removing the maximum common indent from the
        // beginning of text lines. The common indent is calculated in getPattern.
        dedent(elements2, commonIndent) {
          const trimmed = [];
          for (let element of elements2) {
            if (element instanceof Placeable) {
              trimmed.push(element);
              continue;
            }
            if (element instanceof Indent) {
              element.value = element.value.slice(0, element.value.length - commonIndent);
              if (element.value.length === 0) {
                continue;
              }
            }
            let prev = trimmed[trimmed.length - 1];
            if (prev && prev instanceof TextElement) {
              const sum = new TextElement(prev.value + element.value);
              if (this.withSpans) {
                sum.addSpan(prev.span.start, element.span.end);
              }
              trimmed[trimmed.length - 1] = sum;
              continue;
            }
            if (element instanceof Indent) {
              const textElement = new TextElement(element.value);
              if (this.withSpans) {
                textElement.addSpan(element.span.start, element.span.end);
              }
              element = textElement;
            }
            trimmed.push(element);
          }
          const lastElement = trimmed[trimmed.length - 1];
          if (lastElement instanceof TextElement) {
            lastElement.value = lastElement.value.replace(trailingWSRe, "");
            if (lastElement.value.length === 0) {
              trimmed.pop();
            }
          }
          return trimmed;
        }
        getTextElement(ps) {
          let buffer = "";
          let ch;
          while (ch = ps.currentChar()) {
            if (ch === "{" || ch === "}") {
              return new TextElement(buffer);
            }
            if (ch === EOL) {
              return new TextElement(buffer);
            }
            buffer += ch;
            ps.next();
          }
          return new TextElement(buffer);
        }
        getEscapeSequence(ps) {
          const next = ps.currentChar();
          switch (next) {
            case "\\":
            case '"':
              ps.next();
              return `\\${next}`;
            case "u":
              return this.getUnicodeEscapeSequence(ps, next, 4);
            case "U":
              return this.getUnicodeEscapeSequence(ps, next, 6);
            default:
              throw new ParseError("E0025", next);
          }
        }
        getUnicodeEscapeSequence(ps, u, digits) {
          ps.expectChar(u);
          let sequence = "";
          for (let i = 0; i < digits; i++) {
            const ch = ps.takeHexDigit();
            if (!ch) {
              throw new ParseError("E0026", `\\${u}${sequence}${ps.currentChar()}`);
            }
            sequence += ch;
          }
          return `\\${u}${sequence}`;
        }
        getPlaceable(ps) {
          ps.expectChar("{");
          ps.skipBlank();
          const expression = this.getExpression(ps);
          ps.expectChar("}");
          return new Placeable(expression);
        }
        getExpression(ps) {
          const selector = this.getInlineExpression(ps);
          ps.skipBlank();
          if (ps.currentChar() === "-") {
            if (ps.peek() !== ">") {
              ps.resetPeek();
              return selector;
            }
            if (selector instanceof MessageReference) {
              if (selector.attribute === null) {
                throw new ParseError("E0016");
              } else {
                throw new ParseError("E0018");
              }
            } else if (selector instanceof TermReference) {
              if (selector.attribute === null) {
                throw new ParseError("E0017");
              }
            } else if (selector instanceof Placeable) {
              throw new ParseError("E0029");
            }
            ps.next();
            ps.next();
            ps.skipBlankInline();
            ps.expectLineEnd();
            const variants = this.getVariants(ps);
            return new SelectExpression(selector, variants);
          }
          if (selector instanceof TermReference && selector.attribute !== null) {
            throw new ParseError("E0019");
          }
          return selector;
        }
        getInlineExpression(ps) {
          if (ps.currentChar() === "{") {
            return this.getPlaceable(ps);
          }
          if (ps.isNumberStart()) {
            return this.getNumber(ps);
          }
          if (ps.currentChar() === '"') {
            return this.getString(ps);
          }
          if (ps.currentChar() === "$") {
            ps.next();
            const id = this.getIdentifier(ps);
            return new VariableReference(id);
          }
          if (ps.currentChar() === "-") {
            ps.next();
            const id = this.getIdentifier(ps);
            let attr;
            if (ps.currentChar() === ".") {
              ps.next();
              attr = this.getIdentifier(ps);
            }
            let args;
            ps.peekBlank();
            if (ps.currentPeek() === "(") {
              ps.skipToPeek();
              args = this.getCallArguments(ps);
            }
            return new TermReference(id, attr, args);
          }
          if (ps.isIdentifierStart()) {
            const id = this.getIdentifier(ps);
            ps.peekBlank();
            if (ps.currentPeek() === "(") {
              if (!/^[A-Z][A-Z0-9_-]*$/.test(id.name)) {
                throw new ParseError("E0008");
              }
              ps.skipToPeek();
              let args = this.getCallArguments(ps);
              return new FunctionReference(id, args);
            }
            let attr;
            if (ps.currentChar() === ".") {
              ps.next();
              attr = this.getIdentifier(ps);
            }
            return new MessageReference(id, attr);
          }
          throw new ParseError("E0028");
        }
        getCallArgument(ps) {
          const exp = this.getInlineExpression(ps);
          ps.skipBlank();
          if (ps.currentChar() !== ":") {
            return exp;
          }
          if (exp instanceof MessageReference && exp.attribute === null) {
            ps.next();
            ps.skipBlank();
            const value = this.getLiteral(ps);
            return new NamedArgument(exp.id, value);
          }
          throw new ParseError("E0009");
        }
        getCallArguments(ps) {
          const positional = [];
          const named = [];
          const argumentNames = /* @__PURE__ */ new Set();
          ps.expectChar("(");
          ps.skipBlank();
          while (true) {
            if (ps.currentChar() === ")") {
              break;
            }
            const arg = this.getCallArgument(ps);
            if (arg instanceof NamedArgument) {
              if (argumentNames.has(arg.name.name)) {
                throw new ParseError("E0022");
              }
              named.push(arg);
              argumentNames.add(arg.name.name);
            } else if (argumentNames.size > 0) {
              throw new ParseError("E0021");
            } else {
              positional.push(arg);
            }
            ps.skipBlank();
            if (ps.currentChar() === ",") {
              ps.next();
              ps.skipBlank();
              continue;
            }
            break;
          }
          ps.expectChar(")");
          return new CallArguments(positional, named);
        }
        getString(ps) {
          ps.expectChar('"');
          let value = "";
          let ch;
          while (ch = ps.takeChar((x) => x !== '"' && x !== EOL)) {
            if (ch === "\\") {
              value += this.getEscapeSequence(ps);
            } else {
              value += ch;
            }
          }
          if (ps.currentChar() === EOL) {
            throw new ParseError("E0020");
          }
          ps.expectChar('"');
          return new StringLiteral(value);
        }
        getLiteral(ps) {
          if (ps.isNumberStart()) {
            return this.getNumber(ps);
          }
          if (ps.currentChar() === '"') {
            return this.getString(ps);
          }
          throw new ParseError("E0014");
        }
      }
      class Indent {
        constructor(value, start, end) {
          this.type = "Indent";
          this.value = value;
          this.span = new Span(start, end);
        }
      }
      function indentExceptFirstLine(content) {
        return content.split("\n").join("\n    ");
      }
      function includesNewLine(elem) {
        return elem instanceof TextElement && elem.value.includes("\n");
      }
      function isSelectExpr(elem) {
        return elem instanceof Placeable && elem.expression instanceof SelectExpression;
      }
      function shouldStartOnNewLine(pattern) {
        const isMultiline = pattern.elements.some(isSelectExpr) || pattern.elements.some(includesNewLine);
        if (isMultiline) {
          const firstElement = pattern.elements[0];
          if (firstElement instanceof TextElement) {
            const firstChar = firstElement.value[0];
            if (firstChar === "[" || firstChar === "." || firstChar === "*") {
              return false;
            }
          }
          return true;
        }
        return false;
      }
      const HAS_ENTRIES = 1;
      class FluentSerializer {
        constructor({ withJunk = false } = {}) {
          this.withJunk = withJunk;
        }
        serialize(resource) {
          if (!(resource instanceof Resource)) {
            throw new Error(`Unknown resource type: ${resource}`);
          }
          let state = 0;
          const parts = [];
          for (const entry of resource.body) {
            if (!(entry instanceof Junk) || this.withJunk) {
              parts.push(this.serializeEntry(entry, state));
              if (!(state & HAS_ENTRIES)) {
                state |= HAS_ENTRIES;
              }
            }
          }
          return parts.join("");
        }
        serializeEntry(entry, state = 0) {
          if (entry instanceof Message) {
            return serializeMessage(entry);
          }
          if (entry instanceof Term) {
            return serializeTerm(entry);
          }
          if (entry instanceof Comment) {
            if (state & HAS_ENTRIES) {
              return `
${serializeComment(entry, "#")}
`;
            }
            return `${serializeComment(entry, "#")}
`;
          }
          if (entry instanceof GroupComment) {
            if (state & HAS_ENTRIES) {
              return `
${serializeComment(entry, "##")}
`;
            }
            return `${serializeComment(entry, "##")}
`;
          }
          if (entry instanceof ResourceComment) {
            if (state & HAS_ENTRIES) {
              return `
${serializeComment(entry, "###")}
`;
            }
            return `${serializeComment(entry, "###")}
`;
          }
          if (entry instanceof Junk) {
            return serializeJunk(entry);
          }
          throw new Error(`Unknown entry type: ${entry}`);
        }
      }
      function serializeComment(comment, prefix = "#") {
        const prefixed = comment.content.split("\n").map((line) => line.length ? `${prefix} ${line}` : prefix).join("\n");
        return `${prefixed}
`;
      }
      function serializeJunk(junk) {
        return junk.content;
      }
      function serializeMessage(message) {
        const parts = [];
        if (message.comment) {
          parts.push(serializeComment(message.comment));
        }
        parts.push(`${message.id.name} =`);
        if (message.value) {
          parts.push(serializePattern(message.value));
        }
        for (const attribute of message.attributes) {
          parts.push(serializeAttribute(attribute));
        }
        parts.push("\n");
        return parts.join("");
      }
      function serializeTerm(term) {
        const parts = [];
        if (term.comment) {
          parts.push(serializeComment(term.comment));
        }
        parts.push(`-${term.id.name} =`);
        parts.push(serializePattern(term.value));
        for (const attribute of term.attributes) {
          parts.push(serializeAttribute(attribute));
        }
        parts.push("\n");
        return parts.join("");
      }
      function serializeAttribute(attribute) {
        const value = indentExceptFirstLine(serializePattern(attribute.value));
        return `
    .${attribute.id.name} =${value}`;
      }
      function serializePattern(pattern) {
        const content = pattern.elements.map(serializeElement).join("");
        if (shouldStartOnNewLine(pattern)) {
          return `
    ${indentExceptFirstLine(content)}`;
        }
        return ` ${indentExceptFirstLine(content)}`;
      }
      function serializeElement(element) {
        if (element instanceof TextElement) {
          return element.value;
        }
        if (element instanceof Placeable) {
          return serializePlaceable(element);
        }
        throw new Error(`Unknown element type: ${element}`);
      }
      function serializePlaceable(placeable) {
        const expr = placeable.expression;
        if (expr instanceof Placeable) {
          return `{${serializePlaceable(expr)}}`;
        }
        if (expr instanceof SelectExpression) {
          return `{ ${serializeExpression(expr)}}`;
        }
        return `{ ${serializeExpression(expr)} }`;
      }
      function serializeExpression(expr) {
        if (expr instanceof StringLiteral) {
          return `"${expr.value}"`;
        }
        if (expr instanceof NumberLiteral) {
          return expr.value;
        }
        if (expr instanceof VariableReference) {
          return `$${expr.id.name}`;
        }
        if (expr instanceof TermReference) {
          let out = `-${expr.id.name}`;
          if (expr.attribute) {
            out += `.${expr.attribute.name}`;
          }
          if (expr.arguments) {
            out += serializeCallArguments(expr.arguments);
          }
          return out;
        }
        if (expr instanceof MessageReference) {
          let out = expr.id.name;
          if (expr.attribute) {
            out += `.${expr.attribute.name}`;
          }
          return out;
        }
        if (expr instanceof FunctionReference) {
          return `${expr.id.name}${serializeCallArguments(expr.arguments)}`;
        }
        if (expr instanceof SelectExpression) {
          let out = `${serializeExpression(expr.selector)} ->`;
          for (let variant of expr.variants) {
            out += serializeVariant(variant);
          }
          return `${out}
`;
        }
        if (expr instanceof Placeable) {
          return serializePlaceable(expr);
        }
        throw new Error(`Unknown expression type: ${expr}`);
      }
      function serializeVariant(variant) {
        const key = serializeVariantKey(variant.key);
        const value = indentExceptFirstLine(serializePattern(variant.value));
        if (variant.default) {
          return `
   *[${key}]${value}`;
        }
        return `
    [${key}]${value}`;
      }
      function serializeCallArguments(expr) {
        const positional = expr.positional.map(serializeExpression).join(", ");
        const named = expr.named.map(serializeNamedArgument).join(", ");
        if (expr.positional.length > 0 && expr.named.length > 0) {
          return `(${positional}, ${named})`;
        }
        return `(${positional || named})`;
      }
      function serializeNamedArgument(arg) {
        const value = serializeExpression(arg.value);
        return `${arg.name.name}: ${value}`;
      }
      function serializeVariantKey(key) {
        if (key instanceof Identifier) {
          return key.name;
        }
        if (key instanceof NumberLiteral) {
          return key.value;
        }
        throw new Error(`Unknown variant key type: ${key}`);
      }
      class Visitor {
        visit(node) {
          let visit = this[`visit${node.type}`];
          if (typeof visit === "function") {
            visit.call(this, node);
          } else {
            this.genericVisit(node);
          }
        }
        genericVisit(node) {
          for (const key of Object.keys(node)) {
            let prop = node[key];
            if (prop instanceof BaseNode) {
              this.visit(prop);
            } else if (Array.isArray(prop)) {
              for (let element of prop) {
                this.visit(element);
              }
            }
          }
        }
      }
      class Transformer extends Visitor {
        visit(node) {
          let visit = this[`visit${node.type}`];
          if (typeof visit === "function") {
            return visit.call(this, node);
          }
          return this.genericVisit(node);
        }
        genericVisit(node) {
          for (const key of Object.keys(node)) {
            let prop = node[key];
            if (prop instanceof BaseNode) {
              let newVal = this.visit(prop);
              if (newVal === void 0) {
                delete node[key];
              } else {
                node[key] = newVal;
              }
            } else if (Array.isArray(prop)) {
              let newVals = [];
              for (let element of prop) {
                let newVal = this.visit(element);
                if (newVal !== void 0) {
                  newVals.push(newVal);
                }
              }
              node[key] = newVals;
            }
          }
          return node;
        }
      }
      function parse2(source, opts) {
        const parser = new FluentParser(opts);
        return parser.parse(source);
      }
      function serialize(resource, opts) {
        const serializer = new FluentSerializer(opts);
        return serializer.serialize(resource);
      }
      function lineOffset(source, pos) {
        return source.substring(0, pos).split("\n").length - 1;
      }
      function columnOffset(source, pos) {
        const fromIndex = pos - 1;
        const prevLineBreak = source.lastIndexOf("\n", fromIndex);
        if (prevLineBreak === -1) {
          return pos;
        }
        return pos - prevLineBreak - 1;
      }
      exports2.Annotation = Annotation;
      exports2.Attribute = Attribute;
      exports2.BaseComment = BaseComment;
      exports2.BaseLiteral = BaseLiteral;
      exports2.BaseNode = BaseNode;
      exports2.CallArguments = CallArguments;
      exports2.Comment = Comment;
      exports2.FluentParser = FluentParser;
      exports2.FluentSerializer = FluentSerializer;
      exports2.FunctionReference = FunctionReference;
      exports2.GroupComment = GroupComment;
      exports2.Identifier = Identifier;
      exports2.Junk = Junk;
      exports2.Message = Message;
      exports2.MessageReference = MessageReference;
      exports2.NamedArgument = NamedArgument;
      exports2.NumberLiteral = NumberLiteral;
      exports2.ParseError = ParseError;
      exports2.Pattern = Pattern;
      exports2.Placeable = Placeable;
      exports2.Resource = Resource;
      exports2.ResourceComment = ResourceComment;
      exports2.SelectExpression = SelectExpression;
      exports2.Span = Span;
      exports2.StringLiteral = StringLiteral;
      exports2.SyntaxNode = SyntaxNode;
      exports2.Term = Term;
      exports2.TermReference = TermReference;
      exports2.TextElement = TextElement;
      exports2.Transformer = Transformer;
      exports2.VariableReference = VariableReference;
      exports2.Variant = Variant;
      exports2.Visitor = Visitor;
      exports2.columnOffset = columnOffset;
      exports2.lineOffset = lineOffset;
      exports2.parse = parse2;
      exports2.serialize = serialize;
      exports2.serializeExpression = serializeExpression;
      exports2.serializeVariantKey = serializeVariantKey;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/tslib/tslib.es6.js
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read,
  __rest: () => __rest,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values
});
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function")
      throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn)
      context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access)
      context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_ = accept(result.get))
        descriptor.get = _;
      if (_ = accept(result.set))
        descriptor.set = _;
      if (_ = accept(result.init))
        initializers.push(_);
    } else if (_ = accept(result)) {
      if (kind === "field")
        initializers.push(_);
      else
        descriptor[key] = _;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol")
    name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar(m, o) {
  for (var p in m)
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
      __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
        __createBinding(result, mod, k);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
var extendStatics, __assign, __createBinding, __setModuleDefault;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.js"() {
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    };
    __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
  }
});

// node_modules/lower-case/dist/index.js
var require_dist = __commonJS({
  "node_modules/lower-case/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lowerCase = exports.localeLowerCase = void 0;
    var SUPPORTED_LOCALE = {
      tr: {
        regexp: /\u0130|\u0049|\u0049\u0307/g,
        map: {
          \u0130: "i",
          I: "\u0131",
          I\u0307: "i"
        }
      },
      az: {
        regexp: /\u0130/g,
        map: {
          \u0130: "i",
          I: "\u0131",
          I\u0307: "i"
        }
      },
      lt: {
        regexp: /\u0049|\u004A|\u012E|\u00CC|\u00CD|\u0128/g,
        map: {
          I: "i\u0307",
          J: "j\u0307",
          \u012E: "\u012F\u0307",
          \u00CC: "i\u0307\u0300",
          \u00CD: "i\u0307\u0301",
          \u0128: "i\u0307\u0303"
        }
      }
    };
    function localeLowerCase(str, locale) {
      var lang = SUPPORTED_LOCALE[locale.toLowerCase()];
      if (lang)
        return lowerCase(str.replace(lang.regexp, function(m) {
          return lang.map[m];
        }));
      return lowerCase(str);
    }
    exports.localeLowerCase = localeLowerCase;
    function lowerCase(str) {
      return str.toLowerCase();
    }
    exports.lowerCase = lowerCase;
  }
});

// node_modules/no-case/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/no-case/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.noCase = void 0;
    var lower_case_1 = require_dist();
    var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
    var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
    function noCase(input, options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.splitRegexp, splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lower_case_1.lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? " " : _d;
      var result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
      var start = 0;
      var end = result.length;
      while (result.charAt(start) === "\0")
        start++;
      while (result.charAt(end - 1) === "\0")
        end--;
      return result.slice(start, end).split("\0").map(transform).join(delimiter);
    }
    exports.noCase = noCase;
    function replace(input, re, value) {
      if (re instanceof RegExp)
        return input.replace(re, value);
      return re.reduce(function(input2, re2) {
        return input2.replace(re2, value);
      }, input);
    }
  }
});

// node_modules/pascal-case/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/pascal-case/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pascalCase = exports.pascalCaseTransformMerge = exports.pascalCaseTransform = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var no_case_1 = require_dist2();
    function pascalCaseTransform(input, index) {
      var firstChar = input.charAt(0);
      var lowerChars = input.substr(1).toLowerCase();
      if (index > 0 && firstChar >= "0" && firstChar <= "9") {
        return "_" + firstChar + lowerChars;
      }
      return "" + firstChar.toUpperCase() + lowerChars;
    }
    exports.pascalCaseTransform = pascalCaseTransform;
    function pascalCaseTransformMerge(input) {
      return input.charAt(0).toUpperCase() + input.slice(1).toLowerCase();
    }
    exports.pascalCaseTransformMerge = pascalCaseTransformMerge;
    function pascalCase2(input, options) {
      if (options === void 0) {
        options = {};
      }
      return no_case_1.noCase(input, tslib_1.__assign({ delimiter: "", transform: pascalCaseTransform }, options));
    }
    exports.pascalCase = pascalCase2;
  }
});

// node_modules/camel-case/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/camel-case/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.camelCase = exports.camelCaseTransformMerge = exports.camelCaseTransform = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var pascal_case_1 = require_dist3();
    function camelCaseTransform(input, index) {
      if (index === 0)
        return input.toLowerCase();
      return pascal_case_1.pascalCaseTransform(input, index);
    }
    exports.camelCaseTransform = camelCaseTransform;
    function camelCaseTransformMerge(input, index) {
      if (index === 0)
        return input.toLowerCase();
      return pascal_case_1.pascalCaseTransformMerge(input);
    }
    exports.camelCaseTransformMerge = camelCaseTransformMerge;
    function camelCase2(input, options) {
      if (options === void 0) {
        options = {};
      }
      return pascal_case_1.pascalCase(input, tslib_1.__assign({ transform: camelCaseTransform }, options));
    }
    exports.camelCase = camelCase2;
  }
});

// node_modules/upper-case-first/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/upper-case-first/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.upperCaseFirst = void 0;
    function upperCaseFirst(input) {
      return input.charAt(0).toUpperCase() + input.substr(1);
    }
    exports.upperCaseFirst = upperCaseFirst;
  }
});

// node_modules/capital-case/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/capital-case/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.capitalCase = exports.capitalCaseTransform = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var no_case_1 = require_dist2();
    var upper_case_first_1 = require_dist5();
    function capitalCaseTransform(input) {
      return upper_case_first_1.upperCaseFirst(input.toLowerCase());
    }
    exports.capitalCaseTransform = capitalCaseTransform;
    function capitalCase(input, options) {
      if (options === void 0) {
        options = {};
      }
      return no_case_1.noCase(input, tslib_1.__assign({ delimiter: " ", transform: capitalCaseTransform }, options));
    }
    exports.capitalCase = capitalCase;
  }
});

// node_modules/upper-case/dist/index.js
var require_dist7 = __commonJS({
  "node_modules/upper-case/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.upperCase = exports.localeUpperCase = void 0;
    var SUPPORTED_LOCALE = {
      tr: {
        regexp: /[\u0069]/g,
        map: {
          i: "\u0130"
        }
      },
      az: {
        regexp: /[\u0069]/g,
        map: {
          i: "\u0130"
        }
      },
      lt: {
        regexp: /[\u0069\u006A\u012F]\u0307|\u0069\u0307[\u0300\u0301\u0303]/g,
        map: {
          i\u0307: "I",
          j\u0307: "J",
          \u012F\u0307: "\u012E",
          i\u0307\u0300: "\xCC",
          i\u0307\u0301: "\xCD",
          i\u0307\u0303: "\u0128"
        }
      }
    };
    function localeUpperCase(str, locale) {
      var lang = SUPPORTED_LOCALE[locale.toLowerCase()];
      if (lang)
        return upperCase(str.replace(lang.regexp, function(m) {
          return lang.map[m];
        }));
      return upperCase(str);
    }
    exports.localeUpperCase = localeUpperCase;
    function upperCase(str) {
      return str.toUpperCase();
    }
    exports.upperCase = upperCase;
  }
});

// node_modules/constant-case/dist/index.js
var require_dist8 = __commonJS({
  "node_modules/constant-case/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.constantCase = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var no_case_1 = require_dist2();
    var upper_case_1 = require_dist7();
    function constantCase2(input, options) {
      if (options === void 0) {
        options = {};
      }
      return no_case_1.noCase(input, tslib_1.__assign({ delimiter: "_", transform: upper_case_1.upperCase }, options));
    }
    exports.constantCase = constantCase2;
  }
});

// node_modules/dot-case/dist/index.js
var require_dist9 = __commonJS({
  "node_modules/dot-case/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dotCase = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var no_case_1 = require_dist2();
    function dotCase(input, options) {
      if (options === void 0) {
        options = {};
      }
      return no_case_1.noCase(input, tslib_1.__assign({ delimiter: "." }, options));
    }
    exports.dotCase = dotCase;
  }
});

// node_modules/header-case/dist/index.js
var require_dist10 = __commonJS({
  "node_modules/header-case/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.headerCase = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var capital_case_1 = require_dist6();
    function headerCase(input, options) {
      if (options === void 0) {
        options = {};
      }
      return capital_case_1.capitalCase(input, tslib_1.__assign({ delimiter: "-" }, options));
    }
    exports.headerCase = headerCase;
  }
});

// node_modules/param-case/dist/index.js
var require_dist11 = __commonJS({
  "node_modules/param-case/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.paramCase = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var dot_case_1 = require_dist9();
    function paramCase(input, options) {
      if (options === void 0) {
        options = {};
      }
      return dot_case_1.dotCase(input, tslib_1.__assign({ delimiter: "-" }, options));
    }
    exports.paramCase = paramCase;
  }
});

// node_modules/path-case/dist/index.js
var require_dist12 = __commonJS({
  "node_modules/path-case/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pathCase = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var dot_case_1 = require_dist9();
    function pathCase(input, options) {
      if (options === void 0) {
        options = {};
      }
      return dot_case_1.dotCase(input, tslib_1.__assign({ delimiter: "/" }, options));
    }
    exports.pathCase = pathCase;
  }
});

// node_modules/sentence-case/dist/index.js
var require_dist13 = __commonJS({
  "node_modules/sentence-case/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sentenceCase = exports.sentenceCaseTransform = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var no_case_1 = require_dist2();
    var upper_case_first_1 = require_dist5();
    function sentenceCaseTransform(input, index) {
      var result = input.toLowerCase();
      if (index === 0)
        return upper_case_first_1.upperCaseFirst(result);
      return result;
    }
    exports.sentenceCaseTransform = sentenceCaseTransform;
    function sentenceCase(input, options) {
      if (options === void 0) {
        options = {};
      }
      return no_case_1.noCase(input, tslib_1.__assign({ delimiter: " ", transform: sentenceCaseTransform }, options));
    }
    exports.sentenceCase = sentenceCase;
  }
});

// node_modules/snake-case/dist/index.js
var require_dist14 = __commonJS({
  "node_modules/snake-case/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.snakeCase = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var dot_case_1 = require_dist9();
    function snakeCase2(input, options) {
      if (options === void 0) {
        options = {};
      }
      return dot_case_1.dotCase(input, tslib_1.__assign({ delimiter: "_" }, options));
    }
    exports.snakeCase = snakeCase2;
  }
});

// node_modules/change-case/dist/index.js
var require_dist15 = __commonJS({
  "node_modules/change-case/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_dist4(), exports);
    tslib_1.__exportStar(require_dist6(), exports);
    tslib_1.__exportStar(require_dist8(), exports);
    tslib_1.__exportStar(require_dist9(), exports);
    tslib_1.__exportStar(require_dist10(), exports);
    tslib_1.__exportStar(require_dist2(), exports);
    tslib_1.__exportStar(require_dist11(), exports);
    tslib_1.__exportStar(require_dist3(), exports);
    tslib_1.__exportStar(require_dist12(), exports);
    tslib_1.__exportStar(require_dist13(), exports);
    tslib_1.__exportStar(require_dist14(), exports);
  }
});

// ftl.js
var ftl_exports = {};
__export(ftl_exports, {
  default: () => ftl_default
});
module.exports = __toCommonJS(ftl_exports);

// node_modules/fluent-transpiler/index.js
var import_syntax = __toESM(require_syntax(), 1);
var import_change_case = __toESM(require_dist15(), 1);
var exportDefault = `(id, params) => {
	const source = __exports[id] ?? __exports['_'+id]
	if (typeof source === 'undefined') return '*** '+id+' ***'
	if (typeof source === 'function') return source(params)
	return source
}
`;
var compile = (src, opts) => {
  const options = {
    comments: true,
    errorOnJunk: true,
    includeMessages: [],
    excludeMessages: [],
    //treeShaking: false,
    variableNotation: "camelCase",
    disableMinify: false,
    // TODO needs better name strictInterface?
    useIsolating: false,
    params: "params",
    exportDefault,
    ...opts
  };
  if (!Array.isArray(options.locale))
    options.locale = [options.locale];
  if (!Array.isArray(options.includeMessages))
    options.includeMessages = [options.includeMessages];
  if (!Array.isArray(options.excludeMessages))
    options.excludeMessages = [options.excludeMessages];
  const metadata = {};
  const exports = [];
  const functions = {};
  let variable;
  const regexpValidVariable = /^[a-zA-Z]+[a-zA-Z0-9]*$/;
  const compileAssignment = (data) => {
    variable = compileType(data);
    metadata[variable] = {
      id: data.name,
      term: false,
      params: false
    };
    return variable;
  };
  const compileFunctionArguments = (data) => {
    var _a, _b;
    const positional = (_a = data.arguments) == null ? void 0 : _a.positional.map((data2) => {
      return types[data2.type](data2);
    });
    const named = (_b = data.arguments) == null ? void 0 : _b.named.reduce((obj, data2) => {
      const key = data2.name.name;
      const value = compileType(data2.value, data2.type);
      obj[key] = value;
      return obj;
    }, {});
    return { positional, named };
  };
  const compileType = (data, parent) => {
    try {
      return types[data.type](data, parent);
    } catch (e) {
      console.error("Error:", e.message, data, e.stack);
      throw new Error(e.message, { cause: data, stack: e.stack });
    }
  };
  const types = {
    Identifier: (data, parent) => {
      const value = parent === "Attribute" ? data.name : variableNotation[options.variableNotation](data.name);
      if (value.includes("-")) {
        return `'${value}'`;
      }
      if (["const", "default", "enum", "if"].includes(value)) {
        return "_" + value;
      }
      return value;
    },
    Attribute: (data) => {
      const key = compileType(data.id, data.type);
      const value = compileType(data.value, data.type);
      return `  ${key}: ${value}`;
    },
    Pattern: (data, parent) => {
      return "`" + data.elements.map((data2) => {
        return compileType(data2, parent);
      }).join("") + "`";
    },
    // resources
    Term: (data) => {
      const assignment = compileAssignment(data.id);
      const templateStringLiteral = compileType(data.value);
      metadata[assignment].term = true;
      if (metadata[assignment].params) {
        return `const ${assignment} = (${options.params}) => ${templateStringLiteral}
`;
      }
      return `const ${assignment} = ${templateStringLiteral}
`;
    },
    Message: (data) => {
      const assignment = compileAssignment(data.id);
      if (options.includeMessages.length && !options.includeMessages.includes(assignment)) {
        return "";
      }
      if (options.excludeMessages.length && options.excludeMessages.includes(assignment)) {
        return "";
      }
      const templateStringLiteral = data.value && compileType(data.value, data.type);
      metadata[assignment].attributes = data.attributes.length;
      let attributes = {};
      if (metadata[assignment].attributes) {
        attributes = `{
${data.attributes.map((data2) => {
          return "  " + compileType(data2);
        }).join(",\n")}
  }`;
      }
      let message = "";
      if (!options.disableMinify) {
        if (metadata[assignment].attributes) {
          if (metadata[assignment].params) {
            message = `(${options.params}) => ({
  value:${templateStringLiteral},
  attributes:${attributes}
})
`;
          } else {
            message = `{
  value: ${templateStringLiteral},
  attributes: ${attributes}
}
`;
          }
        } else if (metadata[assignment].params) {
          message = `(${options.params}) => ${templateStringLiteral}
`;
        } else {
          message = `${templateStringLiteral}
`;
        }
      } else {
        message = `(${metadata[assignment].params ? options.params : ""}) => ({
  value:${templateStringLiteral},
  attributes:${attributes}
})
`;
      }
      if (assignment === metadata[assignment].id) {
        exports.push(`${assignment}`);
      } else {
        exports.push(`'${metadata[assignment].id}': ${assignment}`);
      }
      return `export const ${assignment} = ${message}`;
      return "";
    },
    Comment: (data) => {
      if (options.comments)
        return `// # ${data.content}
`;
      return "";
    },
    GroupComment: (data) => {
      if (options.comments)
        return `// ## ${data.content}
`;
      return "";
    },
    ResourceComment: (data) => {
      if (options.comments)
        return `// ### ${data.content}
`;
      return "";
    },
    Junk: (data) => {
      if (options.errorOnJunk) {
        throw new Error("Junk found", { cause: data });
      }
      console.error("Error: Skipping Junk", JSON.stringify(data, null, 2));
      return "";
    },
    // Element
    TextElement: (data) => {
      return data.value.replaceAll("`", "\\`");
    },
    Placeable: (data, parent) => {
      return `${options.useIsolating ? "\u2068" : ""}\${${compileType(
        data.expression,
        parent
      )}}${options.useIsolating ? "\u2069" : ""}`;
    },
    // Expression
    StringLiteral: (data, parent) => {
      if (["NamedArgument"].includes(parent)) {
        return `${data.value}`;
      }
      return `"${data.value}"`;
    },
    NumberLiteral: (data) => {
      const decimal = Number.parseFloat(data.value);
      const number = Number.isInteger(decimal) ? Number.parseInt(data.value) : decimal;
      return Intl.NumberFormat(options.locale).format(number);
    },
    VariableReference: (data, parent) => {
      functions.__formatVariable = true;
      metadata[variable].params = true;
      const value = `${options.params}?.${data.id.name}`;
      if (["Message", "Variant", "Attribute"].includes(parent)) {
        return `__formatVariable(${value})`;
      }
      return value;
    },
    MessageReference: (data) => {
      const messageName = compileType(data.id);
      metadata[variable].params ||= metadata[messageName].params;
      if (!options.disableMinify) {
        if (metadata[messageName].params) {
          return `${messageName}(${options.params})`;
        }
        return `${messageName}`;
      }
      return `${messageName}(${metadata[messageName].params ? options.params : ""})`;
    },
    TermReference: (data) => {
      const termName = compileType(data.id);
      metadata[variable].params ||= metadata[termName].params;
      let params;
      if (metadata[termName].params) {
        let { named } = compileFunctionArguments(data);
        named = JSON.stringify(named);
        if (named) {
          params = `{ ...${options.params}, ${named.substring(
            1,
            named.length - 1
          )} }`;
        } else {
          params = options.params;
        }
      }
      if (!options.disableMinify) {
        if (metadata[termName].params) {
          return `${termName}(${params})`;
        }
        return `${termName}`;
      }
      return `${termName}(${params ? params : ""})`;
    },
    NamedArgument: (data) => {
      const key = data.name.name;
      const value = compileType(data.value, data.type);
      return `${key}: ${value}`;
    },
    SelectExpression: (data) => {
      functions.__select = true;
      metadata[variable].params = true;
      const value = compileType(data.selector);
      let fallback;
      return `__select(
    ${value},
    {
${data.variants.filter((data2) => {
        if (data2.default) {
          fallback = compileType(data2.value, data2.type);
        }
        return !data2.default;
      }).map((data2) => {
        return "  " + compileType(data2);
      }).join(",\n")}
    },
    ${fallback}
  )`;
    },
    Variant: (data, parent) => {
      const key = compileType(data.key);
      const value = compileType(data.value, data.type);
      return `    '${key}': ${value}`;
    },
    FunctionReference: (data) => {
      return `${types[data.id.name](compileFunctionArguments(data))}`;
    },
    // Functions
    DATETIME: (data) => {
      functions.__formatDateTime = true;
      const { positional, named } = data;
      const value = positional.shift();
      return `__formatDateTime(${value}, ${JSON.stringify(named)})`;
    },
    RELATIVETIME: (data) => {
      functions.__formatRelativeTime = true;
      const { positional, named } = data;
      const value = positional.shift();
      return `__formatRelativeTime(${value}, ${JSON.stringify(named)})`;
    },
    NUMBER: (data) => {
      functions.__formatNumber = true;
      const { positional, named } = data;
      const value = positional.shift();
      return `__formatNumber(${value}, ${JSON.stringify(named)})`;
    }
  };
  if (/\t/.test(src)) {
    console.error(
      "Source file contains tab characters (	), replacing with <space>x4"
    );
    src = src.replace(/\t/g, "    ");
  }
  const { body } = (0, import_syntax.parse)(src);
  let translations = ``;
  for (const data of body) {
    translations += compileType(data);
  }
  let output = ``;
  if (functions.__formatVariable || functions.__formatDateTime || functions.__formatNumber) {
    output += `const __locales = ${JSON.stringify(opts.locale)}
`;
  }
  if (functions.__formatRelativeTime) {
    output += `
const __relativeTimeDiff = (d) => {
  const msPerMinute = 60 * 1000
  const msPerHour = msPerMinute * 60
  const msPerDay = msPerHour * 24
  const msPerWeek = msPerDay * 7
  const msPerMonth = msPerDay * 30
  const msPerYear = msPerDay * 365.25
  const elapsed = d - new Date()
	
  if (Math.abs(elapsed) < msPerMinute) {
    return [Math.round(elapsed / 1000), 'second']
  }
  if (Math.abs(elapsed) < msPerHour) {
  	return [Math.round(elapsed / msPerMinute), 'minute']
  }
  if (Math.abs(elapsed) < msPerDay) {
  	return [Math.round(elapsed / msPerHour), 'hour']
  }
  if (Math.abs(elapsed) < msPerWeek * 2) {
  	return [Math.round(elapsed / msPerDay), 'day']
  }
  if (Math.abs(elapsed) < msPerMonth) {
  	return [Math.round(elapsed / msPerWeek), 'week']
  }
  if (Math.abs(elapsed) < msPerYear) {
  	return [Math.round(elapsed / msPerMonth), 'month']
  }
  return [Math.round(elapsed / msPerYear), 'year']
}
const __formatRelativeTime = (value, options) => {
  if (typeof value === 'string') value = new Date(value)
  if (isNaN(value.getTime())) return value
  try {
	const [duration, unit] = __relativeTimeDiff(value)
	return new Intl.RelativeTimeFormat(__locales, options).format(duration, unit)
  } catch (e) {}
  return new Intl.DateTimeFormat(__locales, options).format(value)
}
  `;
  }
  if (functions.__formatDateTime) {
    output += `
const __formatDateTime = (value, options) => {
	if (typeof value === 'string') value = new Date(value)
	if (isNaN(value.getTime())) return value
	return new Intl.DateTimeFormat(__locales, options).format(value)
}
`;
  }
  if (functions.__formatVariable || functions.__formatNumber) {
    output += `
const __formatNumber = (value, options) => {
	return new Intl.NumberFormat(__locales, options).format(value)
}
`;
  }
  if (functions.__formatVariable) {
    output += `
const __formatVariable = (value) => {
  if (typeof value === 'string') return value
  const decimal =  Number.parseFloat(value)
  const number = Number.isInteger(decimal) ? Number.parseInt(value) : decimal
  return __formatNumber(number)
}
`;
  }
  if (functions.__select) {
    output += `
const __select = (value, cases, fallback, options) => {
	const pluralRules = new Intl.PluralRules(__locales, options)
	const rule = pluralRules.select(value)
	return cases[value] ?? cases[rule] ?? fallback
}
`;
  }
  output += `
` + translations;
  output += `const __exports = {
  ${exports.join(",\n  ")}
}`;
  output += `
export default ${options.exportDefault}`;
  return output;
};
var variableNotation = {
  camelCase: import_change_case.camelCase,
  pascalCase: import_change_case.pascalCase,
  snakeCase: import_change_case.snakeCase,
  constantCase: import_change_case.constantCase
};
var fluent_transpiler_default = compile;

// node_modules/ajv-ftl-i18n/transpile.js
var exportDefault2 = `(errors) => {
  if (!errors?.length) return
  for (const e of errors) {
    let { keyword } = e
    if (keyword === 'false schema') keyword = 'falseSchema'
    let source = __exports[keyword] ?? __exports['_'+keyword]
    let values = {}
    if (keyword === 'errorMessage') {
      const [message, ...valuesPairs] = e.message.split(', ')
      ;(valuesPairs.join(', ').match(regExpJsonPointerPairs) ?? []).forEach(pair => {
        const [key, value] = pair.split(':')
        values[key] = value.replace(regExpJsonPointerQuote, '')
      })
      source ??= __exports[message] ?? __exports['_'+message] ?? e.message
    } else {
      source ??= __exports.defaultMessage
    }
    if (typeof source === 'function') {
      e.message = source({keyword:e.keyword, ...e.params, ...values})
    } else {
      e.message = source
    }
  }
}
const regExpJsonPointerPairs = /([a-zA-Z0-9_-]+):(".*"|[^,"]+)/g
const regExpJsonPointerQuote = /(^"|"$)/g
`;
var transpile_default = (ftl, options) => fluent_transpiler_default(ftl, {
  comments: false,
  ...options,
  exportDefault: exportDefault2
});

// node_modules/ajv-ftl-i18n/locale/ar.js
var type = `\u0642\u064A\u0645\u0629 \u0647\u0630\u0627 \u0627\u0644\u062D\u0642\u0644 \u063A\u064A\u0631 \u0635\u0627\u0644\u062D\u0629`;
var elements = `${type}`;
var values = `${type}`;

// node_modules/ajv-ftl-i18n/index.js
var transpile = transpile_default;

// ftl.js
var ftl_default = transpile;
